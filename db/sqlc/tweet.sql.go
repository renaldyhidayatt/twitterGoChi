// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: tweet.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTweet = `-- name: CreateTweet :one
INSERT INTO "tweet" ("status", "tweetBy", "tweetImage", "postedOn") VALUES ($1,$2,$3,$4) RETURNING tweet_id, status, "tweetBy", "tweetImage", "postedOn"
`

type CreateTweetParams struct {
	Status     string    `json:"status"`
	TweetBy    int32     `json:"tweetBy"`
	TweetImage string    `json:"tweetImage"`
	PostedOn   time.Time `json:"postedOn"`
}

func (q *Queries) CreateTweet(ctx context.Context, arg CreateTweetParams) (Tweet, error) {
	row := q.queryRow(ctx, q.createTweetStmt, createTweet,
		arg.Status,
		arg.TweetBy,
		arg.TweetImage,
		arg.PostedOn,
	)
	var i Tweet
	err := row.Scan(
		&i.TweetID,
		&i.Status,
		&i.TweetBy,
		&i.TweetImage,
		&i.PostedOn,
	)
	return i, err
}

const getHashTagTweet = `-- name: GetHashTagTweet :many
SELECT u.user_id, "firstName", "lastName", username, email, password, "profileImage", "profileCover", following, followers, bio, country, website, tweet_id, status, "tweetBy", "tweetImage", "postedOn", "trendID", hashtag, t.user_id, "tweetId", "createdOn" FROM users u LEFT JOIN tweet p ON p.tweetBy=u.user_id INNER JOIN trends t ON p.tweet_id=t.tweetId WHERE hashtag=$1 ORDER BY postedOn DESC
`

type GetHashTagTweetRow struct {
	UserID       int32     `json:"user_id"`
	FirstName    string    `json:"firstName"`
	LastName     string    `json:"lastName"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	Password     string    `json:"password"`
	ProfileImage string    `json:"profileImage"`
	ProfileCover string    `json:"profileCover"`
	Following    int32     `json:"following"`
	Followers    int32     `json:"followers"`
	Bio          string    `json:"bio"`
	Country      string    `json:"country"`
	Website      string    `json:"website"`
	TweetID      int32     `json:"tweet_id"`
	Status       string    `json:"status"`
	TweetBy      int32     `json:"tweetBy"`
	TweetImage   string    `json:"tweetImage"`
	PostedOn     time.Time `json:"postedOn"`
	TrendID      int32     `json:"trendID"`
	Hashtag      string    `json:"hashtag"`
	UserID_2     int32     `json:"user_id_2"`
	TweetId      int32     `json:"tweetId"`
	CreatedOn    time.Time `json:"createdOn"`
}

func (q *Queries) GetHashTagTweet(ctx context.Context, hashtag string) ([]GetHashTagTweetRow, error) {
	rows, err := q.query(ctx, q.getHashTagTweetStmt, getHashTagTweet, hashtag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHashTagTweetRow
	for rows.Next() {
		var i GetHashTagTweetRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ProfileImage,
			&i.ProfileCover,
			&i.Following,
			&i.Followers,
			&i.Bio,
			&i.Country,
			&i.Website,
			&i.TweetID,
			&i.Status,
			&i.TweetBy,
			&i.TweetImage,
			&i.PostedOn,
			&i.TrendID,
			&i.Hashtag,
			&i.UserID_2,
			&i.TweetId,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMention = `-- name: GetMention :many
SELECT  user_id, "firstName", "lastName", username, email, password, "profileImage", "profileCover", following, followers, bio, country, website FROM "users" WHERE "username" LIKE $1 OR "firstName" LIKE $1 OR "lastName" LIKE $1 LIMIT 5
`

func (q *Queries) GetMention(ctx context.Context, username string) ([]User, error) {
	rows, err := q.query(ctx, q.getMentionStmt, getMention, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ProfileImage,
			&i.ProfileCover,
			&i.Following,
			&i.Followers,
			&i.Bio,
			&i.Country,
			&i.Website,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweet = `-- name: GetTweet :one
SELECT tweet_id, status, "tweetBy", "tweetImage", "postedOn", user_id, "firstName", "lastName", username, email, password, "profileImage", "profileCover", following, followers, bio, country, website FROM "tweet" LEFT JOIN "users" ON users.user_id=tweet."tweetBy" WHERE tweet.tweet_id=$1 AND tweet."tweetBy"=$2
`

type GetTweetParams struct {
	TweetID int32 `json:"tweet_id"`
	TweetBy int32 `json:"tweetBy"`
}

type GetTweetRow struct {
	TweetID      int32          `json:"tweet_id"`
	Status       string         `json:"status"`
	TweetBy      int32          `json:"tweetBy"`
	TweetImage   string         `json:"tweetImage"`
	PostedOn     time.Time      `json:"postedOn"`
	UserID       sql.NullInt32  `json:"user_id"`
	FirstName    sql.NullString `json:"firstName"`
	LastName     sql.NullString `json:"lastName"`
	Username     sql.NullString `json:"username"`
	Email        sql.NullString `json:"email"`
	Password     sql.NullString `json:"password"`
	ProfileImage sql.NullString `json:"profileImage"`
	ProfileCover sql.NullString `json:"profileCover"`
	Following    sql.NullInt32  `json:"following"`
	Followers    sql.NullInt32  `json:"followers"`
	Bio          sql.NullString `json:"bio"`
	Country      sql.NullString `json:"country"`
	Website      sql.NullString `json:"website"`
}

func (q *Queries) GetTweet(ctx context.Context, arg GetTweetParams) (GetTweetRow, error) {
	row := q.queryRow(ctx, q.getTweetStmt, getTweet, arg.TweetID, arg.TweetBy)
	var i GetTweetRow
	err := row.Scan(
		&i.TweetID,
		&i.Status,
		&i.TweetBy,
		&i.TweetImage,
		&i.PostedOn,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.ProfileImage,
		&i.ProfileCover,
		&i.Following,
		&i.Followers,
		&i.Bio,
		&i.Country,
		&i.Website,
	)
	return i, err
}

const getTweetAll = `-- name: GetTweetAll :many
SELECT tweet_id, status, "tweetBy", "tweetImage", "postedOn", user_id, "firstName", "lastName", username, email, password, "profileImage", "profileCover", following, followers, bio, country, website FROM tweet t LEFT JOIN users u ON t."tweetBy"=u.user_id WHERE t."tweetBy"=$1 UNION SELECT tweet_id, status, "tweetBy", "tweetImage", "postedOn", user_id, "firstName", "lastName", username, email, password, "profileImage", "profileCover", following, followers, bio, country, website FROM tweet t LEFT JOIN users u ON t."tweetBy"=u.user_id WHERE t."tweetBy" IN (SELECT follow.receiver FROM follow WHERE follow.sender=$1) ORDER BY postedOn
`

type GetTweetAllRow struct {
	TweetID      int32          `json:"tweet_id"`
	Status       string         `json:"status"`
	TweetBy      int32          `json:"tweetBy"`
	TweetImage   string         `json:"tweetImage"`
	PostedOn     time.Time      `json:"postedOn"`
	UserID       sql.NullInt32  `json:"user_id"`
	FirstName    sql.NullString `json:"firstName"`
	LastName     sql.NullString `json:"lastName"`
	Username     sql.NullString `json:"username"`
	Email        sql.NullString `json:"email"`
	Password     sql.NullString `json:"password"`
	ProfileImage sql.NullString `json:"profileImage"`
	ProfileCover sql.NullString `json:"profileCover"`
	Following    sql.NullInt32  `json:"following"`
	Followers    sql.NullInt32  `json:"followers"`
	Bio          sql.NullString `json:"bio"`
	Country      sql.NullString `json:"country"`
	Website      sql.NullString `json:"website"`
}

func (q *Queries) GetTweetAll(ctx context.Context, tweetby int32) ([]GetTweetAllRow, error) {
	rows, err := q.query(ctx, q.getTweetAllStmt, getTweetAll, tweetby)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTweetAllRow
	for rows.Next() {
		var i GetTweetAllRow
		if err := rows.Scan(
			&i.TweetID,
			&i.Status,
			&i.TweetBy,
			&i.TweetImage,
			&i.PostedOn,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ProfileImage,
			&i.ProfileCover,
			&i.Following,
			&i.Followers,
			&i.Bio,
			&i.Country,
			&i.Website,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweetByMe = `-- name: GetTweetByMe :many
SELECT tweet_id, status, "tweetBy", "tweetImage", "postedOn", user_id, "firstName", "lastName", username, email, password, "profileImage", "profileCover", following, followers, bio, country, website FROM tweet, users WHERE "tweetBy"=user_id AND user_id=$1 ORDER BY postedOn DESC
`

type GetTweetByMeRow struct {
	TweetID      int32     `json:"tweet_id"`
	Status       string    `json:"status"`
	TweetBy      int32     `json:"tweetBy"`
	TweetImage   string    `json:"tweetImage"`
	PostedOn     time.Time `json:"postedOn"`
	UserID       int32     `json:"user_id"`
	FirstName    string    `json:"firstName"`
	LastName     string    `json:"lastName"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	Password     string    `json:"password"`
	ProfileImage string    `json:"profileImage"`
	ProfileCover string    `json:"profileCover"`
	Following    int32     `json:"following"`
	Followers    int32     `json:"followers"`
	Bio          string    `json:"bio"`
	Country      string    `json:"country"`
	Website      string    `json:"website"`
}

func (q *Queries) GetTweetByMe(ctx context.Context, userID int32) ([]GetTweetByMeRow, error) {
	rows, err := q.query(ctx, q.getTweetByMeStmt, getTweetByMe, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTweetByMeRow
	for rows.Next() {
		var i GetTweetByMeRow
		if err := rows.Scan(
			&i.TweetID,
			&i.Status,
			&i.TweetBy,
			&i.TweetImage,
			&i.PostedOn,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.ProfileImage,
			&i.ProfileCover,
			&i.Following,
			&i.Followers,
			&i.Bio,
			&i.Country,
			&i.Website,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tweetCounts = `-- name: TweetCounts :one
SELECT  count(*) as "count" FROM "tweet" WHERE "tweetBy"=$1
`

func (q *Queries) TweetCounts(ctx context.Context, tweetby int32) (int64, error) {
	row := q.queryRow(ctx, q.tweetCountsStmt, tweetCounts, tweetby)
	var count int64
	err := row.Scan(&count)
	return count, err
}
