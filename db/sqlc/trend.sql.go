// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: trend.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTrend = `-- name: CreateTrend :one
INSERT INTO "trends" ("hashtag","tweetId","user_id","createdOn") VALUES ($1,$2,$3,$4) RETURNING "trendID", hashtag, user_id, "tweetId", "createdOn"
`

type CreateTrendParams struct {
	Hashtag   string    `json:"hashtag"`
	TweetId   int32     `json:"tweetId"`
	UserID    int32     `json:"user_id"`
	CreatedOn time.Time `json:"createdOn"`
}

func (q *Queries) CreateTrend(ctx context.Context, arg CreateTrendParams) (Trend, error) {
	row := q.queryRow(ctx, q.createTrendStmt, createTrend,
		arg.Hashtag,
		arg.TweetId,
		arg.UserID,
		arg.CreatedOn,
	)
	var i Trend
	err := row.Scan(
		&i.TrendID,
		&i.Hashtag,
		&i.UserID,
		&i.TweetId,
		&i.CreatedOn,
	)
	return i, err
}

const getTrendByHash = `-- name: GetTrendByHash :many
SELECT DISTINCT "hashtag" FROM "trends" WHERE "hashtag" LIKE $1 LIMIT 5
`

func (q *Queries) GetTrendByHash(ctx context.Context, hashtag string) ([]string, error) {
	rows, err := q.query(ctx, q.getTrendByHashStmt, getTrendByHash, hashtag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hashtag string
		if err := rows.Scan(&hashtag); err != nil {
			return nil, err
		}
		items = append(items, hashtag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrends = `-- name: GetTrends :many
SELECT "trendID", hashtag, user_id, "tweetId", "createdOn", tweet_id, status, "tweetBy", "tweetImage", "postedOn",COUNT("tweet_id") AS "tweetsCount" FROM trends t LEFT JOIN tweet p ON p.tweet_id=t.tweetId AND status LIKE CONCAT("%#","hashtag","%") GROUP BY "hashtag" ORDER BY "tweetsCount" DESC LIMIT 3
`

type GetTrendsRow struct {
	TrendID     int32          `json:"trendID"`
	Hashtag     string         `json:"hashtag"`
	UserID      int32          `json:"user_id"`
	TweetId     int32          `json:"tweetId"`
	CreatedOn   time.Time      `json:"createdOn"`
	TweetID     sql.NullInt32  `json:"tweet_id"`
	Status      sql.NullString `json:"status"`
	TweetBy     sql.NullInt32  `json:"tweetBy"`
	TweetImage  sql.NullString `json:"tweetImage"`
	PostedOn    sql.NullTime   `json:"postedOn"`
	TweetsCount int64          `json:"tweetsCount"`
}

func (q *Queries) GetTrends(ctx context.Context) ([]GetTrendsRow, error) {
	rows, err := q.query(ctx, q.getTrendsStmt, getTrends)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrendsRow
	for rows.Next() {
		var i GetTrendsRow
		if err := rows.Scan(
			&i.TrendID,
			&i.Hashtag,
			&i.UserID,
			&i.TweetId,
			&i.CreatedOn,
			&i.TweetID,
			&i.Status,
			&i.TweetBy,
			&i.TweetImage,
			&i.PostedOn,
			&i.TweetsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
